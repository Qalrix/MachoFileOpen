import subprocess
from typing import Dict, Any, List, Union

class Decompiler:
    def __init__(self):
        self.decompilers = {
            'ghidra': self._decompile_with_ghidra,
            'radare2': self._decompile_with_radare2,
            'hopper': self._decompile_with_hopper,
            'simulated': self._simulate_decompilation
        }

    def decompile(self, macho_data: Dict[str, Any], language: Union[str, bool] = 'auto') -> str:
        """Decompile Mach-O binary to specified language"""

        # Handle boolean or string input
        if isinstance(language, bool):
            language = 'auto'
        elif not isinstance(language, str):
            language = 'auto'

        # Normalize language string
        language = language.lower() if language else 'auto'

        # Try to use actual decompilers if available
        for decompiler_name, decompile_func in self.decompilers.items():
            try:
                result = decompile_func(macho_data, language)
                if result and isinstance(result, str) and not result.startswith('Decompilation failed'):
                    return result
            except Exception as e:
                print(f"Decompiler {decompiler_name} failed: {str(e)}")
                continue

        # Fall back to simulated decompilation
        return self._simulate_decompilation(macho_data, language)

    def _decompile_with_ghidra(self, macho_data: Dict[str, Any], language: str) -> Union[str, None]:
        """Decompile using Ghidra"""
        # Implementation would call Ghidra headless
        return None

    def _decompile_with_radare2(self, macho_data: Dict[str, Any], language: str) -> Union[str, None]:
        """Decompile using radare2"""
        try:
            file_path = macho_data.get('file_path', '')
            if not file_path:
                return None
            cmd = ['r2', '-qc', 'aaaa; pdg;', file_path]
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=30)
            return result.stdout if result.stdout else None
        except:
            return None

    def _decompile_with_hopper(self, macho_data: Dict[str, Any], language: str) -> Union[str, None]:
        """Decompile using Hopper"""
        try:
            file_path = macho_data.get('file_path', '')
            if not file_path:
                return None
            cmd = ['hopper', '-script', f'decompile_{language}.py', file_path]
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=30)
            return result.stdout if result.stdout else None
        except:
            return None

    def _simulate_decompilation(self, macho_data: Dict[str, Any], language: str) -> str:
        """Simulate decompilation for demonstration purposes"""

        # Ensure language is a string
        if not isinstance(language, str):
            language = 'auto'

        language = language.lower()

        # Auto-detect if needed
        if language == 'auto':
            languages = macho_data.get('languages', [])
            if 'Objective-C' in languages:
                language = 'objc'
            elif 'C++' in languages:
                language = 'cpp'
            else:
                language = 'c'

        if language == 'objc' or language == 'objective-c' or language == 'objectivec':
            return self._generate_objective_c_code(macho_data)
        elif language == 'cpp' or language == 'c++' or language == 'cxx':
            return self._generate_cpp_code(macho_data)
        else:
            return self._generate_c_code(macho_data)

    def _generate_objective_c_code(self, macho_data: Dict[str, Any]) -> str:
        """Generate Objective-C decompilation"""
        code = []

        code.append("// ==========================================")
        code.append("// Objective-C Decompiled Code")
        code.append(f"// File: {macho_data.get('file_path', 'Unknown')}")
        code.append(f"// Type: {macho_data.get('file_type', 'Unknown')}")
        code.append("// Generated by Mach-O File Analyzer")
        code.append("// ==========================================\n")

        # Import frameworks
        code.append("#import <Foundation/Foundation.h>")
        code.append("#import <objc/runtime.h>\n")

        # Generate class definitions from extracted data
        objc_classes = macho_data.get('objc_classes', [])
        if objc_classes:
            for objc_class in objc_classes:
                if isinstance(objc_class, dict):
                    class_name = objc_class.get('name', 'UnknownClass')
                    inheritance = objc_class.get('inheritance', 'NSObject')
                    protocols = objc_class.get('protocols', [])

                    code.append(f"\n// Class: {class_name}")

                    # Interface declaration
                    code.append(f"@interface {class_name} : {inheritance}")

                    # Add protocols
                    if protocols and isinstance(protocols, list):
                        protocol_str = ', '.join([p for p in protocols if isinstance(p, str)])
                        if protocol_str:
                            code.append(f"                      <{protocol_str}>")

                    code.append("\n// Properties")
                    code.append("// @property (nonatomic, strong) ...\n")

                    code.append("// Instance Methods")
                    code.append("- (instancetype)init;")
                    code.append("- (void)dealloc;\n")

                    code.append("@end\n")

                    # Implementation
                    code.append(f"@implementation {class_name}")
                    code.append("\n- (instancetype)init {")
                    code.append("    self = [super init];")
                    code.append("    if (self) {")
                    code.append("        // Initialize instance variables")
                    code.append("    }")
                    code.append("    return self;")
                    code.append("}\n")

                    code.append("- (void)dealloc {")
                    code.append("    // Clean up resources")
                    code.append("    [super dealloc];")
                    code.append("}\n")
                    code.append("@end\n")
        else:
            code.append("// No Objective-C classes detected\n")
            code.append("@interface NSObject (Decompiled)")
            code.append("- (void)decompiledMethod;")
            code.append("@end\n")
            code.append("@implementation NSObject (Decompiled)")
            code.append("- (void)decompiledMethod {")
            code.append("    NSLog(@\"Decompiled Objective-C method\");")
            code.append("}")
            code.append("@end\n")

        # Generate method implementations from extracted methods
        objc_methods = macho_data.get('objc_methods', [])
        if objc_methods:
            code.append("\n// Extracted Methods\n")
            for i, method in enumerate(objc_methods[:20]):  # Limit to 20 methods
                if isinstance(method, dict):
                    signature = method.get('signature', '- (void)decompiledMethod;')
                    offset = method.get('offset', '0x0')
                    code.append(f"{signature.rstrip(';')} {{")
                    code.append(f"    // Method at offset {offset}")
                    code.append("    // Decompiled pseudo-code:")
                    code.append("    // - Perform Objective-C operations")
                    code.append("    // - Send messages")
                    code.append("    // - Return result")
                    code.append("    return nil;")
                    code.append("}\n")

        # Generate protocol definitions
        objc_protocols = macho_data.get('objc_protocols', [])
        if objc_protocols:
            code.append("\n// Protocol Definitions\n")
            for protocol in objc_protocols[:10]:
                if isinstance(protocol, dict):
                    protocol_name = protocol.get('name', 'UnknownProtocol')
                    code.append(f"@protocol {protocol_name}")
                    methods = protocol.get('methods', [])
                    if methods and isinstance(methods, list):
                        for method in methods[:5]:
                            if isinstance(method, str):
                                code.append(f"- (void){method};")
                    else:
                        code.append("- (void)requiredMethod;")
                        code.append("@optional")
                        code.append("- (void)optionalMethod;")
                    code.append("@end\n")

        # Main function
        code.append("\nint main(int argc, const char * argv[]) {")
        code.append("    @autoreleasepool {")
        code.append("        NSLog(@\"Objective-C binary decompiled successfully\");")
        code.append("        ")
        code.append("        // Example usage")
        code.append("        id object = [[NSObject alloc] init];")
        code.append("        [object performSelector:@selector(description)];")
        code.append("    }")
        code.append("    return 0;")
        code.append("}\n")

        return '\n'.join(code)

    def _generate_cpp_code(self, macho_data: Dict[str, Any]) -> str:
        """Generate C++ decompilation"""
        code = []

        code.append("// ==========================================")
        code.append("// C++ Decompiled Code")
        code.append(f"// File: {macho_data.get('file_path', 'Unknown')}")
        code.append(f"// Type: {macho_data.get('file_type', 'Unknown')}")
        code.append("// Generated by Mach-O File Analyzer")
        code.append("// ==========================================\n")

        # Standard headers
        code.append("#include <iostream>")
        code.append("#include <string>")
        code.append("#include <vector>")
        code.append("#include <map>")
        code.append("#include <memory>\n")

        # Namespace
        code.append("namespace DecompiledBinary {")
        code.append("    using namespace std;\n")

        # Generate class definitions
        cpp_classes = macho_data.get('cpp_classes', {})
        if cpp_classes and isinstance(cpp_classes, dict):
            for class_name, info in cpp_classes.items():
                if isinstance(class_name, str) and isinstance(info, dict):
                    code.append(f"    class {class_name} {{")
                    code.append("    private:")
                    code.append("        // Member variables")
                    code.append("        int m_private_data;\n")
                    code.append("    protected:")
                    code.append("        // Protected members")
                    code.append("        string m_protected_string;\n")
                    code.append("    public:")
                    code.append(f"        {class_name}() {{")
                    code.append("            // Constructor")
                    code.append("            m_private_data = 0;")
                    code.append("        }")
                    code.append(f"\n        virtual ~{class_name}() {{")
                    code.append("            // Virtual destructor")
                    code.append("        }\n")

                    # Add methods
                    methods = info.get('methods', [])
                    if methods and isinstance(methods, list):
                        for method in methods[:10]:
                            if isinstance(method, str):
                                code.append(f"        virtual void {method}() {{")
                                code.append(f"            // Virtual function")
                                code.append("            // Decompiled implementation")
                                code.append("        }\n")

                    code.append("    };\n")
        else:
            code.append("    // Sample C++ Class")
            code.append("    class DecompiledClass {")
            code.append("    private:")
            code.append("        int m_value;")
            code.append("    public:")
            code.append("        DecompiledClass() : m_value(0) {}")
            code.append("        virtual ~DecompiledClass() {}")
            code.append("        void setValue(int val) { m_value = val; }")
            code.append("        int getValue() const { return m_value; }")
            code.append("    };\n")

        # Template definitions
        code.append("    // Template instantiations")
        code.append("    template<typename T>")
        code.append("    class DecompiledTemplate {")
        code.append("    private:")
        code.append("        T m_data;")
        code.append("    public:")
        code.append("        DecompiledTemplate(const T& data) : m_data(data) {}")
        code.append("        T getData() const { return m_data; }")
        code.append("    };\n")

        # Function definitions from symbols
        symbols = macho_data.get('symbols', [])
        if symbols and isinstance(symbols, list):
            code.append("    // Extracted Functions\n")
            functions = []
            for s in symbols:
                if isinstance(s, dict):
                    if s.get('type') in ['N_SECT', 'N_ABS']:
                        functions.append(s)

            for func in functions[:20]:
                if isinstance(func, dict):
                    func_name = func.get('demangled', func.get('name', 'unknown_function'))
                    if isinstance(func_name, str):
                        code.append(f"    extern \"C\" void {func_name}() {{")
                        code.append(f"        // Function at {func.get('value', '0x0')}")
                        code.append("        // Reconstructed C++ implementation")
                        code.append("    }\n")

        code.append("} // namespace DecompiledBinary\n")

        # Main function
        code.append("\nint main() {")
        code.append("    using namespace DecompiledBinary;")
        code.append("    std::cout << \"C++ binary decompiled successfully\" << std::endl;")
        code.append("    ")
        code.append("    // Example template usage")
        code.append("    DecompiledTemplate<int> intTemplate(42);")
        code.append("    DecompiledTemplate<std::string> stringTemplate(\"test\");")
        code.append("    ")
        code.append("    return 0;")
        code.append("}\n")

        return '\n'.join(code)

    def _generate_c_code(self, macho_data: Dict[str, Any]) -> str:
        """Generate C decompilation"""
        code = []

        code.append("// ==========================================")
        code.append("// C Decompiled Code")
        code.append(f"// File: {macho_data.get('file_path', 'Unknown')}")
        code.append(f"// Type: {macho_data.get('file_type', 'Unknown')}")
        code.append("// Generated by MachoFileOpen")
        code.append("// ==========================================\n")

        # Standard headers
        code.append("#include <stdio.h>")
        code.append("#include <stdlib.h>")
        code.append("#include <string.h>\n")

        # Data structures
        code.append("// Reconstructed Data Structures\n")
        code.append("typedef struct {")
        code.append("    unsigned char* data;")
        code.append("    size_t size;")
        code.append("} DecompiledData;\n")

        sections = macho_data.get('sections', [])
        if sections and isinstance(sections, list):
            code.append("// Global Variables\n")
            var_count = 0
            for segment in sections:
                if isinstance(segment, dict):
                    for subsection in segment.get('sections', [])[:5]:
                        if isinstance(subsection, dict):
                            var_name = f"g_{subsection.get('name', 'data')}".replace('.', '_')
                            size_val = subsection.get('size', '0x0')
                            if isinstance(size_val, str):
                                code.append(f"static unsigned char {var_name}[{size_val}];")
                                var_count += 1
            if var_count == 0:
                code.append("// No global variables detected")
            code.append("")

        # Function definitions
        symbols = macho_data.get('symbols', [])
        if symbols and isinstance(symbols, list):
            code.append("// Function Prototypes\n")
            functions = []
            for s in symbols:
                if isinstance(s, dict):
                    if s.get('type') in ['N_SECT', 'N_ABS']:
                        functions.append(s)

            for func in functions[:20]:
                if isinstance(func, dict):
                    func_name = func.get('name', 'unknown_function')
                    if isinstance(func_name, str):
                        func_name = func_name.lstrip('_')
                        code.append(f"void {func_name}(void);")
            code.append("")

            code.append("// Function Implementations\n")
            for func in functions[:20]:
                if isinstance(func, dict):
                    func_name = func.get('name', 'unknown_function')
                    if isinstance(func_name, str):
                        func_name = func_name.lstrip('_')
                        code.append(f"void {func_name}(void) {{")
                        code.append(f"    // Decompiled function at {func.get('value', '0x0')}")
                        code.append("    // Reconstructed C code")
                        code.append("    return;")
                        code.append("}\n")

        # Main function
        code.append("\nint main(int argc, char* argv[]) {")
        code.append("    printf(\"C binary decompiled successfully\\n\");")
        code.append("    ")
        code.append("    // Memory allocation example")
        code.append("    DecompiledData* data = (DecompiledData*)malloc(sizeof(DecompiledData));")
        code.append("    if (data) {")
        code.append("        data->data = NULL;")
        code.append("        data->size = 0;")
        code.append("        free(data);")
        code.append("    }")
        code.append("    ")
        code.append("    return 0;")
        code.append("}\n")

        return '\n'.join(code)

    def generateHeader(self, decompiled_code: str, language: str = 'cpp') -> str:
        """Generate header file from decompiled code"""
        if not isinstance(language, str):
            language = 'cpp'

        language = language.lower()

        if language == 'c':
            return self._generate_c_header(decompiled_code)
        elif language == 'objc' or language == 'objective-c':
            return self._generate_objc_header(decompiled_code)
        else:
            return self._generate_cpp_header(decompiled_code)

    def _generate_cpp_header(self, decompiled_code: str) -> str:
        """Generate C++ header file"""
        header = []
        header.append("#ifndef DECOMPILED_BINARY_H")
        header.append("#define DECOMPILED_BINARY_H\n")
        header.append("#include <string>")
        header.append("#include <vector>\n")

        # Extract class definitions
        if isinstance(decompiled_code, str):
            lines = decompiled_code.split('\n')
            in_class = False
            for line in lines:
                if 'class ' in line:
                    in_class = True
                if in_class:
                    header.append(line)
                if line.strip() == '};':
                    in_class = False
                    header.append("")

        header.append("#endif // DECOMPILED_BINARY_H")
        return '\n'.join(header)

    def _generate_c_header(self, decompiled_code: str) -> str:
        """Generate C header file"""
        header = []
        header.append("#ifndef DECOMPILED_BINARY_H")
        header.append("#define DECOMPILED_BINARY_H\n")
        header.append("#include <stddef.h>\n")

        # Extract function prototypes
        if isinstance(decompiled_code, str):
            lines = decompiled_code.split('\n')
            for line in lines:
                if 'void' in line and '(' in line and ')' in line and '{' not in line:
                    clean_line = line.strip()
                    if clean_line and not clean_line.startswith('//'):
                        header.append(clean_line.rstrip(';') + ';')

        header.append("\n#endif // DECOMPILED_BINARY_H")
        return '\n'.join(header)

    def _generate_objc_header(self, decompiled_code: str) -> str:
        """Generate Objective-C header file"""
        header = []
        header.append("#ifndef DECOMPILED_BINARY_H")
        header.append("#define DECOMPILED_BINARY_H\n")
        header.append("#import <Foundation/Foundation.h>\n")

        # Extract interface definitions
        if isinstance(decompiled_code, str):
            lines = decompiled_code.split('\n')
            in_interface = False
            for line in lines:
                if '@interface' in line:
                    in_interface = True
                if in_interface:
                    header.append(line)
                if '@end' in line:
                    in_interface = False
                    header.append("")

        header.append("#endif // DECOMPILED_BINARY_H")
        return '\n'.join(header)
